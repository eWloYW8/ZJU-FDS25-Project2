\documentclass{report}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{algorithm}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{titling}
\usepackage{titlesec}
\usepackage{minted}
\usepackage{datetime}
\usepackage{tabularx}
\usepackage{ragged2e}
\usepackage{booktabs}
\usepackage{makecell}

\titleformat{\chapter}[display]
  {\bfseries\Huge}
  {Chapter \, \thechapter}
  {5pt}
  {}

\titlespacing{\chapter}
  {0pt}
  {-50pt}
  {20pt}

  
\setminted{linenos=true,tabsize=4,style=colorful,breaklines,frame=lines}

\geometry{a4paper, margin=1in}

\title{\Huge\textbf{Hard Autograd for Algebraic Expressions}}
\author{\LARGE\textbf{Hao Yi}}
\date{\LARGE\textbf{Date: \the\year-\the\month-\the\day}}

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}
\section*{Problem Description}
We aim to implement an automatic differentiation system for algebraic expressions, which computes the partial derivatives of the input expression with respect to each variable and outputs them in a specified format.

\subsection*{Input Specification}
The input is an infix expression containing the following elements:
\begin{itemize}
    \item \textbf{Operators}: 
    \begin{itemize}
        \item Parentheses \texttt{( )}, power \texttt{\^}, multiplication/division \texttt{* /}, addition/subtraction \texttt{+ -}, and commas \texttt{,} (for function arguments).
        \item Operator precedence (descending): Parentheses $\rightarrow$ Power $\rightarrow$ Multiplication/Division $\rightarrow$ Addition/Subtraction.
    \end{itemize}
    \item \textbf{Mathematical Functions} (Bonus):
    \begin{itemize}
        \item Logarithms: \texttt{ln(A)}, \texttt{log(A, B)}.
        \item Trigonometric: \texttt{cos(A)}, \texttt{sin(A)}, \texttt{tan(A)}.
        \item Exponential: \texttt{pow(A, B)}, \texttt{exp(A)}.
    \end{itemize}
    \item \textbf{Operands}:
    \begin{itemize}
        \item Literal constants: Integers (e.g., \texttt{2}, \texttt{-5}).
        \item Variables: Lowercase strings not matching reserved function names (e.g., \texttt{xx}, \texttt{xy}).
    \end{itemize}
\end{itemize}

\subsection*{Output Specification}
For each variable in the input expression, output its partial derivative expression:
\begin{itemize}
    \item Sorted lexicographically by variable names.
    \item Each line: \texttt{variable: derivative\_expression}, where the derivative is computed symbolically without simplification.
\end{itemize}

\subsection*{Requirements}
\begin{itemize}
    \item Correctly parse the input expression considering operator precedence and associativity.
    \item Construct an expression tree to facilitate differentiation.
    \item (Bonus) Support mathematical functions and simplify results using at least two rules (e.g., $0 \cdot x \rightarrow 0$, $1 \cdot x \rightarrow x$).
    \item (Bonus) Avoid complex STL containers; use minimal data structures.
\end{itemize}

\section*{Algorithm Background}
The \textbf{Shunting Yard Algorithm}, proposed by Edsger Dijkstra, is a stack-based method to parse infix expressions into postfix notation (Reverse Polish Notation, RPN). It elegantly handles operator precedence, associativity, and parentheses while preserving the original semantics of the expression. This algorithm is particularly suitable for constructing expression trees, which are essential for symbolic differentiation.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\chapter{Algorithm Specification}

Before sketching the main program flow, I will first introduce the main algorithms used in this project, which include the transform between string and expression tree, the differentiation of the AST, and two simplify method of the AST.

\section{String to Expression Tree}
I adapt the Shunting Yard Algorithm to directly construct an expression tree (AST) rather than generating postfix notation. The key modifications focus on maintaining operator precedence while dynamically building the tree structure.

\begin{enumerate}
    \item \textbf{Token Classification}:
    \begin{itemize}
        \item Operands (constants/variables) become leaf nodes
        \item Operators become internal nodes with left/right children
        \item Functions become specialized nodes with parameter subtrees
    \end{itemize}
    
    \item \textbf{Tree Construction Rules}:
    \begin{itemize}
        \item When popping operators from the stack:
        \begin{enumerate}
            \item Binary operators consume top 2 operands as children
            \item Unary functions consume top 1 operand
            \item The resulting subtree becomes a new operand
        \end{enumerate}
    \end{itemize}
    
    \item \textbf{Parentheses Handling}:
    \begin{itemize}
        \item Left parenthesis pushes to operator stack
        \item Right parenthesis triggers subtree construction until matching '('
    \end{itemize}
\end{enumerate}

\begin{algorithm}[H]
\caption{Modified Shunting Yard for AST Construction}
\begin{algorithmic}[1]
\State Initialize \textit{operator\_stack} and \textit{operand\_stack}
\For{each token in input expression}
    \If{token is operand}
        \State Push to \textit{operand\_stack} as leaf node
    \ElsIf{token is function}
        \State Push to \textit{operator\_stack}
    \ElsIf{token is '('}
        \State Push to \textit{operator\_stack}
    \ElsIf{token is ')'}
        \While{top of \textit{operator\_stack} ≠ '('}
            \State \textit{node} $\gets$ pop \textit{operator\_stack}
            \State Attach operands from \textit{operand\_stack} as children
            \State Push \textit{node} to \textit{operand\_stack}
        \EndWhile
        \State Pop '('
    \Else \Comment{Operator case}
        \While{precedence(token) ≤ top of \textit{operator\_stack}}
            \State Construct subtree and push to \textit{operand\_stack}
        \EndWhile
        \State Push token to \textit{operator\_stack}
    \EndIf
\EndFor
\While{\textit{operator\_stack} not empty}
    \State Finalize remaining subtrees
\EndWhile
\State \Return root node from \textit{operand\_stack}
\end{algorithmic}
\end{algorithm}

\textbf{Data Structures}:
\begin{itemize}
    \item \textit{operator\_stack}: Linked list for holding operators/functions
    \item \textit{operand\_stack}: Linked list for subtrees (AST nodes)
    \item AST Node structure:
    \begin{minted}{c}
typedef struct Node {
    enum NodeType type;
    union {
        long long constant;
        char variable[VARIABLE_NAME_SIZE];
        struct {
            struct Node *left;
            struct Node *right;
        } function;
    } data;
} Node;
    \end{minted}
\end{itemize}

The algorithm maintains $O(n)$ time complexity while enabling direct tree construction through strategic stack operations. Function arguments are handled through recursive parsing when encountering commas or parentheses.

\subsection*{Note}
The aforementioned method is applicable to expressions that do not contain functions such as \textbf{sin, cos, or ln}. For expressions containing functions, we need to parse the function's arguments as subtrees during the parsing process. When encountering a function, we first construct its internal components (use \texttt{( , )} as boundary) as a subtree, creating a self-contained function node. This function node is then pushed onto the operator stack. This approach allows us to directly utilize this node in subsequent operations to build the complete expression tree.


\section{Expression Tree To String}

The conversion from an expression tree to a mathematical string requires careful handling of operator precedence and function notation. The recursive algorithm prioritizes correctness of expression semantics over minimal parentheses usage.

\subsection*{Core Conversion Rules}

\begin{enumerate}
    \item \textbf{Node Type Handling}:
    \begin{itemize}
        \item \textit{Constants}: Direct string conversion with negative value wrapping
        \item \textit{Variables}: Name preservation without modification
        \item \textit{Operators}: Infix notation with priority-based parenthesis control
        \item \textit{Functions}: Prefix notation with parameter encapsulation
    \end{itemize}

    \item \textbf{Priority Propagation}:
    \begin{itemize}
        \item Parent priority tracking through recursion context
        \item Priority comparison matrix:
        \begin{equation*}
        \begin{array}{c|cccccc}
        \text{Type} & \text{Add} & \text{Subtract} & \text{Multiply} & \text{Divide} & \text{Power} & \text{Func} \\
        \hline
        \text{Priority} & 1 & 1 & 2 & 2 & 3 & 4 \\
        \end{array}
        \end{equation*}
        \item Right operand priority increases for non-associative operations
    \end{itemize}
\end{enumerate}

\begin{algorithm}[H]
\caption{Recursive Tree Serialization}
\begin{algorithmic}[1]
\Function{NodeToString}{node, parent\_priority}
    \If{node is null}
        \State \Return \text{null}
    \EndIf
    
    \State Allocate output buffer
    \If{node.type == Constant}
        \If{negative \& parent\_priority $>$ 1}
            \State Wrap in parentheses
        \EndIf
    \ElsIf{node.type == Variable}
        \State Copy name directly
    \ElsIf{node.type == Operator}
        \State current\_priority $\gets$ PRIORITY[node.type]
        \State left\_str $\gets$ \Call{NodeToString}{left, current\_priority}
        \State right\_str $\gets$ \Call{NodeToString}{right, current\_priority + $\delta$}
        \If{current\_priority $<$ parent\_priority}
            \State Wrap in parentheses
        \EndIf
    \ElsIf{node.type == Function}
        \State arg\_str $\gets$ \Call{NodeToString}{args, -1}
        \State Format as func\_name(arg\_str)
    \EndIf
    \State \Return formatted string
\EndFunction
\end{algorithmic}
\end{algorithm}

This argorithm does not use any typical Data Structure, but rather a simple array to store the string. It is factually a postorder traversal of the tree, where we first visit the left child, then the right child, and finally connected by the operator which is in the parent node.


\section{Differentiation of Expression Tree}

The differentiation algorithm implements symbolic differentiation rules through recursive tree traversal, handling all fundamental operations and elementary functions. The implementation follows calculus rules while maintaining expression tree structure integrity.

\subsection*{Differentiation Math Rules}

\begin{enumerate}
    \item \textbf{Basic Cases}:
    \begin{itemize}
        \item Constant: $\frac{d}{dx}c = 0$
        \item Variable: $\frac{d}{dx}x = 1$, $\frac{d}{dx}y = 0$ ($y \neq x$)
    \end{itemize}

    \item \textbf{Arithmetic Operations}:
    \begin{itemize}
        \item Addition/Subtraction: Linear combination
        \item Product Rule: $\frac{d}{dx}(uv) = u'v + uv'$
        \item Quotient Rule: $\frac{d}{dx}(\frac{u}{v}) = \frac{u'v - uv'}{v^2}$
        \item Power Rule: $\frac{d}{dx}(u^v) = u^v(v'\ln u + \frac{vu'}{u})$
    \end{itemize}

    \item \textbf{Functions}:
    \begin{itemize}
        \item Trigonometric:
        \begin{align*}
            \frac{d}{dx}\sin u &= u'\cos u \\
            \frac{d}{dx}\cos u &= -u'\sin u \\
            \frac{d}{dx}\tan u &= \frac{u'}{\cos^2 u}
        \end{align*}
        \item Logarithmic/Exponential:
        \begin{align*}
            \frac{d}{dx}\ln u &= \frac{u'}{u} \\
            \frac{d}{dx}\log_v u &= \frac{d}{dx}\left(\frac{\ln u}{\ln v}\right) \\
            \frac{d}{dx}e^u &= u'e^u
        \end{align*}
    \end{itemize}
\end{enumerate}

\begin{algorithm}[H]
\caption{Recursive Tree Differentiation}
\begin{algorithmic}[1]
\Function{Differentiate}{node, variable}
    \If{node is null}
        \State \Return null
    \EndIf
    
    \State Allocate result node
    \If{node.type == Constant}
        \State Return zero node
    \ElsIf{node.type == Variable}
        \State Return 1 if matches variable, else 0
    \ElsIf{node.type == Add \textbf{or} node.type == Subtract}
        \State Differentiate left and right subtrees
        \State Combine results with same operator
    \ElsIf{node.type == Multiply}
        \State Apply product rule:
        \State $result \gets (left' \times right) + (left \times right')$
    \ElsIf{node.type == Divide}
        \State Apply quotient rule:
        \State $result \gets \frac{(left' \times right) - (left \times right')}{right^2}$
    \ElsIf{node.type == Power}
        \State Apply generalized power rule:
        \State $result \gets u^v \times (v'\ln u + \frac{vu'}{u})$
    \ElsIf{node.type == Trigonometric \textbf{or} node.type == Logarithmic}
        \State Apply corresponding differentiation rule
        \State Chain rule for composite functions
    \EndIf
    \State \Return result node
\EndFunction
\end{algorithmic}
\end{algorithm}


\section{One-layer Simplification}

The simplification algorithm performs local optimization on expression trees by applying algebraic identities in a single traversal. This conservative approach ensures correctness while reducing expression complexity through pattern matching.

\subsection*{Simplification Rules}

\begin{enumerate}
    \item Additive Identity: $0 + x = x + 0 = x$
    \item Multiplicative Identity: $1 \times x = x \times 1= x$
    \item Multiplicative Annihilator: $0 \times x = x\times 0 = 0$
    \item Subtractive Identity: $x - 0 = x$
    \item Negative Transformation: $0 - x = -x$
    \item Logarithmic Identity: $\ln(1) = 0$
    \item Power Identities:
    \begin{align*}
        1^x &= 1 \\
        x^0 &= 1 \\
        x^1 &= x
    \end{align*}
    \item Division by Unity: $\frac{x}{1} = x$
    \item Zero Numerator: $\frac{0}{x} = 0$
\end{enumerate}

\begin{algorithm}[H]
\caption{Local Expression Simplification}
\begin{algorithmic}[1]
\Function{Simplify}{node}
    \If{node is null or leaf node}
        \State \Return node \Comment{No simplification possible}
    \EndIf
    
    \State Recursively simplify children
    \If{node.type == Add}
        \If{left child is 0} \Return right child
        \ElsIf{right child is 0} \Return left child
        \EndIf
    \ElsIf{node.type == Subtract}
        \If{right child is 0} \Return left child
        \ElsIf{left child is 0} \Return negated right child
        \EndIf
    \ElsIf{node.type == Multiply}
        \If{either child is 0} \Return zero node
        \ElsIf{left child is 1} \Return right child
        \ElsIf{right child is 1} \Return left child
        \EndIf
    \ElsIf{node.type == Divide}
        \If{numerator is 0} \Return zero node
        \ElsIf{denominator is 1} \Return numerator
        \EndIf
    \ElsIf{node.type == Power}
        \If{base is 1} \Return one node
        \ElsIf{exponent is 0} \Return one node
        \ElsIf{exponent is 1} \Return base
        \EndIf
    \ElsIf{node.type == Logarithm}
        \If{argument is 1} \Return zero node
        \EndIf
    \EndIf
    \State \Return node \Comment{If no rules matched}
\EndFunction
\end{algorithmic}
\end{algorithm}

The algorithm provides basic normalization that improves expression clarity while guaranteeing termination and mathematical correctness. Further simplification would require multi-pass analysis and advanced algebraic techniques.



\section*{Monomial Simplification}

The monomial simplification process converts complex expressions into a normalized monomial form through coefficient consolidation and variable exponent management. This approach systematically handles multiplication/division operations by maintaining a unified representation of coefficients and variables.

\begin{enumerate}
    \item \textbf{Monomial Structure Design}:
    \begin{itemize}
        \item Coefficient components stored as numerator/denominator pair
        \item Variables maintained with associated exponents
        \item Maximum variable limit (MAX\_VARIABLES) prevents memory overflow
    \end{itemize}
    
    \item \textbf{Node Merging Rules}:
    \begin{itemize}
        \item Variable nodes aggregate exponents through recursive traversal
        \item Constant nodes combine multiplicatively with coefficient
        \item Function nodes decompose based on operation type:
        \begin{enumerate}
            \item Multiplication merges left/right subtrees additively
            \item Division handles denominator via negative exponents
            \item Power operations amplify exponents multiplicatively
        \end{enumerate}
    \end{itemize}
    
    \item \textbf{Coefficient Normalization}:
    \begin{itemize}
        \item GCD reduction for numerator/denominator
        \item Sign unification through denominator positivity
        \item Automatic cancellation when exponents reach zero
    \end{itemize}
    
    \item \textbf{Recursive Simplification}:
    \begin{itemize}
        \item Bottom-up traversal of expression tree
        \item Local simplification at each operator node
        \item Preservation of non-multiplicative function structures
    \end{itemize}
\end{enumerate}

\begin{algorithm}[H]
\caption{Monomial Conversion and Simplification}
\begin{algorithmic}[1]
\Procedure{NodeToMonomial}{$node$}
    \State Initialize monomial with unit coefficient
    \If{$node$ is constant}
        \State Multiply monomial coefficient by constant value
    \ElsIf{$node$ is variable}
        \State Add variable to monomial with exponent 1
    \ElsIf{$node$ is multiply/divide}
        \State \textproc{NodeToMonomial}(left child)
        \State Combine with right child using operator-specific rules
    \ElsIf{$node$ is power}
        \State Amplify exponent by power value during merging
    \EndIf
    \State \Return normalized monomial
\EndProcedure

\Procedure{MonomialToNode}{$monomial$}
    \State Create coefficient fraction node
    \For{each variable in monomial}
        \If{exponent $\neq$ 0}
            \State Build power node with exponent value
            \State Multiply with existing expression
        \EndIf
    \EndFor
    \State \Return combined AST structure
\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Data Structures}:
\begin{itemize}
    \item Monomial representation:
    
    It is a structure that contains the coefficient, the coefficient denominator, an array of pointers to the variable nodes, an array of exponents, and the count of variables.
    \begin{minted}{c}
    typedef struct Monomial {
        long long coefficient;
        long long coefficient_denominator;
        Node *node[MAX_VARIABLES];
        long long exponent[MAX_VARIABLES];
        int count;
    } Monomial;
    \end{minted}
\end{itemize}

The simplification achieves $O(n)$ complexity for tree traversal through depth-first processing. Exponent management uses hash-like behavior with linear search (find\_monomial) for variable matching, optimized through in-place updates of exponent values. Coefficient normalization ensures minimal fractional representation through GCD reduction.

\section*{Main Program}
The main program orchestrates the entire process, from reading input to outputting results. It integrates the previously discussed components into a cohesive workflow. \\
\\
The code is shown in code/differentiate\_simplified.c.

\begin{algorithm}[H]
\caption{AST-Based Symbolic Differentiation System Workflow}
\begin{algorithmic}[]
\Require Command line arguments: \textit{expression} [optional \textit{variable}]
\Ensure Output derivative expression for specified variable(s)

\If{argument count $<2$}
    \State Print usage instructions
    \State \Return Error code 1
\Else
    \State Preprocess input expression:
    \begin{itemize}
        \item Add explicit zero for negative signs (e.g., transform "-x" to "0-x")
        \item Remove all whitespace characters
        \item Add implicit multiplication operators (e.g., transform "2x" to "2*x")
    \end{itemize}
    
    \State Construct Abstract Syntax Tree:
    \begin{equation*}
        \text{AST} \gets \text{build\_ast(preprocessed\_expression)}
    \end{equation*}
    
    \State Three-stage expression simplification:
    \begin{enumerate}
        \item Basic simplification (constant folding, identity operation elimination)
        \item Monomial normalization (decompose multiplicative structures)
        \item Final cleanup simplification
    \end{enumerate}
    
    \If{single variable specified}
        \State Perform univariate differentiation:
        \begin{equation*}
            \frac{d(\text{AST})}{dX} \gets \text{differentiate(AST, X)}
        \end{equation*}
        \State Apply three-step simplify
        \State Convert derivative AST to string
        \State Output result in format:
        \begin{equation*}
            X: \text{simplified\_derivative}
        \end{equation*}
    \Else
        \State Extract all unique variables $\mathbb{V}$ from AST
        \For{each variable $X \in \mathbb{V}$}
            \State Compute partial derivative and do three-step simplify
            \State Convert derivative AST to string
            \State Output result in format:
            \begin{equation*}
                X: \text{simplified\_derivative}
            \end{equation*}
        \EndFor
    \EndIf
\EndIf
\end{algorithmic}
\end{algorithm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\chapter{Testing Results}
\section*{Testing Infrastructure}
\begin{itemize}
    \item Test environment: Windows 11 64-bit
    \item Main program compiled with \texttt{gcc 14.2.0} using \texttt{-O2} optimization flag.
    \item SymPy\footnote{A Computer Algebra System (CAS) based on Python} 1.13.3 (Python 3.12.9-64-bit) used for reference results.
\end{itemize}

\section*{Testcases}
\begin{itemize}
    \item \textbf{Testcase 1: Nesting basic math operations}

    The input expression contains nested basic math operations, including addition, subtraction, multiplication, and division.
    \begin{table}[H]
        \centering
        \resizebox{1\columnwidth}{!}{
        \begin{tabular}{c|c|c|c} \hline 
             Input & \makecell[c]{Output\\(No simplification)} & \makecell[c]{Output\\(Simplifiled)}&  \makecell[c]{Reference\\Results}\\ \hline 
             $a+b^c*d$&  \makecell[l]{$a: 1+b^c*(0*ln(b)+c*0/b)*d+b^c*0$ \\ $b: 0+b^c*(0*ln(b)+c*1/b)*d+b^c*0$ \\ $c: 0+b^c*(1*ln(b)+c*0/b)*d+b^c*0$ \\ $d: 0+b^c*(0*ln(b)+c*0/b)*d+b^c*1$}& \makecell[l]{$a: 1$ \\ $b: b^c*c/b*d$ \\ $c: b^c*ln(b)*d$ \\ $d: b^c$ } & \makecell[l]{$a: 1$ \\ $b: c*b^{c-1}*d$ \\ $c: ln(b)*b^c*d$ \\ $d: b^c$}\\ \hline 
             $a*10*b+2^a/a$ & \makecell[l]{$a: (1*10+a*0)*b+a*10*0+$\\\quad$(2^a*(1*ln(2)+a*0/2)*a-2^a*1)/a^2$ \\ $b: (0*10+a*0)*b+a*10*1+$\\\quad$(2^a*(0*ln(2)+a*0/2)*a-2^a*0)/a^2$} & \makecell[l]{$a: 10*b+(2^a*ln(2)*a-2^a)*a^{-2}$ \\ $b: 10*a$} & \makecell[l]{$a: 10*b-2^a/a^2+2^a*ln(2)/a$ \\ $b: a*10$} \\ \hline 
             $xx^2/xy*xy+a^a$ & \makecell[l]{$xx: (xx^2*(0*ln(xx)+2*1/xx)*xy-$\\\quad$xx^2*0)/xy^2*xy+xx^2/xy*0+$\\\quad$a^a*(0*ln(a)+a*0/a)$ \\ $xy: (xx^2*(0*ln(xx)+2*0/xx)*xy-$\\\quad$xx^2*1)/xy^2*xy+xx^2/xy*1+$\\\quad$a^a*(0*ln(a)+a*0/a)$ \\ $a: (xx^2*(0*ln(xx)+2*0/xx)*xy-$\\\quad$xx^2*0)/xy^2*xy+xx^2/xy*0+$\\\quad$a^a*(1*ln(a)+a*1/a)$} & \makecell[l]{$xx: 2*xx$\\$xy: 0$\\$a: a^a*(ln(a)+1)$} & \makecell[l]{$xx: 2*xx$\\$xy: 0$\\$a: a^a*(1+ln(a))$} \\ \hline 
        \end{tabular}
        }
    \end{table}

    \item \textbf{Testcase 2: Operator Associativity}
    
    The input expression contains some operators which have error-prone
    associativity rules.
    \begin{table}[H]
        \centering
        \resizebox{1\columnwidth}{!}{
        \begin{tabular}{c|c|c|c} \hline 
            Input & \makecell[c]{Output\\(No simplification)} & \makecell[c]{Output\\(Simplifiled)}&  \makecell[c]{Reference\\Results}\\ \hline 

            $x/2/2$&
            \makecell[l]{
                $x: ((1*2-x*0)/2^2*2-x/2*0)/2^2$
            }&
            \makecell[l]{
                $x: 1/4$
            }&
            \makecell[l]{
                $x: 1/4$
            }
            \\ \hline 

            \makecell[c]{$1-2*x-2*x$}&
            \makecell[l]{
                $x: 0-(0*x+2*1)-(0*x+2*1)$
            }&
            \makecell[l]{
                $x: -4$
            }&
            \makecell[l]{
                $x: -4$
            }
            \\ \hline 

            \makecell[c]{$x\mathbin{\char`\^}3\mathbin{\char`\^}2$}&
            \makecell[l]{
                $x: x\mathbin{\char`\^}3\mathbin{\char`\^}2*(3\mathbin{\char`\^}2*(0*ln(3)+2*0/3)*ln(x)+3\mathbin{\char`\^}2*1/x)$
            }&
            \makecell[l]{
                $x: 9*x^8$
            }&
            \makecell[l]{
                $x: 9*x^8$
            }
            \\ \hline 
        \end{tabular}
        }
    \end{table}
    Note that the operator \quad \texttt{\^} is right-associative.

    \item \textbf{Testcase 3: Math functions}
    
    The input expression contains mathematical functions such as logarithms and trigonometric functions.
    \begin{table}[H]
        \centering
        \resizebox{1\columnwidth}{!}{
        \begin{tabular}{c|c|c|c} \hline 
            Input & \makecell[c]{Output\\(No simplification)} & \makecell[c]{Output\\(Simplifiled)}&  \makecell[c]{Reference\\Results}\\ \hline 

            $x*ln(y)$&
            \makecell[l]{
                $x: 1*ln(y)+x*0/y$ \\
                $y: 0*ln(y)+x*1/y$
            }&
            \makecell[l]{
                $x: ln(y)$ \\
                $y: x/y$
            }&
            \makecell[l]{
                $x: ln(y)$ \\
                $y: x/y$
            }
            \\ \hline 

            \makecell[c]{$x*ln(x*y)+$\\$y*cos(x)+$\\$y*sin(2*x)$}&
            \makecell[l]{
                $x: 1*ln(x*y)+x*(1*y+x*0)/(x*y)+$\\\quad$0*cos(x)+y*(-1)*sin(x)+$\\\quad$0*sin(2*x)+y*cos(2*x)*(0*x+2*1)$ \\
                $y: 0*ln(x*y)+x*(0*y+x*1)/(x*y)+$\\\quad$1*cos(x)+y*(-0)*sin(x)+$\\\quad$1*sin(2*x)+y*cos(2*x)*(0*x+2*0)$
            }&
            \makecell[l]{
                $x: ln(x*y)+1+y*(-1)*sin(x)+$\\\quad$2*y*cos(2*x)$ \\
                $y: x/y+cos(x)+sin(2*x)$
            }&
            \makecell[l]{
                $x: 2*y*cos(2*x)-y*sin(x)+$\\\quad$ln(x*y)+1$ \\
                $y: x/y+cos(x)+sin(2*x)$
            }
            \\ \hline 

            \makecell[c]{$log(a,b)/log(c,a)$}&
            \makecell[l]{
                $a: ((0/b*ln(a)-ln(b)*1/a)/ln(a)^2*ln(a)/ln(c)-$\\\quad$ln(b)/ln(a)*(1/a*ln(c)-ln(a)*0/c)/ln(c)^2)/(ln(a)/ln(c))^2$ \\
                $b: ((1/b*ln(a)-ln(b)*0/a)/ln(a)^2*ln(a)/ln(c)-$\\\quad$ln(b)/ln(a)*(0/a*ln(c)-ln(a)*0/c)/ln(c)^2)/(ln(a)/ln(c))^2$ \\
                $c: ((0/b*ln(a)-ln(b)*0/a)/ln(a)^2*ln(a)/ln(c)-$\\\quad$ln(b)/ln(a)*(0/a*ln(c)-ln(a)*1/c)/ln(c)^2)/(ln(a)/ln(c))^2$
            }&
            \makecell[l]{
                $a: (-2)*ln(b)*ln(a)^{-3}/a*ln(c)$ \\
                $b: 1/b*ln(a)^{-2}*ln(c)$ \\
                $c: ln(b)*ln(a)^{-2}/c$
            }&
            \makecell[l]{
                $a: -2*ln(b)*ln(c)/(ln(a)^3*a)$ \\
                $b: ln(c)/(ln(a)^2*b)$ \\
                $c: ln(b)/(ln(a)^2*c)$
            }
            \\ \hline 
        \end{tabular}
        }
    \end{table}


    \item \textbf{Testcase 4: Variable Name Tokenization}
    
    The input expression contains variables with similar names to math functions, or variables that are substrings of other variables.
    \begin{table}[H]
        \centering
        \resizebox{1\columnwidth}{!}{
        \begin{tabular}{c|c|c|c} \hline 
            Input & \makecell[c]{Output\\(No simplification)} & \makecell[c]{Output\\(Simplifiled)}&  \makecell[c]{Reference\\Results}\\ \hline 

            $sin(cosval)+cos(cosval)$&
            \makecell[l]{
                $cosval: cos(cosval)*1+$\\\quad$(-1)*sin(cosval)$
            }&
            \makecell[l]{
                $cosval: cos(cosval)+$\\\quad$(-1)*sin(cosval)$
            }&
            \makecell[l]{
                $cosval: cos(cosval)-$\\\quad$sin(cosval)$ 
            }
            \\ \hline 

            $x*xx*xxx$&
            \makecell[l]{
                $x: (1*xx+x*0)*xxx+x*xx*0$ \\
                $xx: (0*xx+x*1)*xxx+x*xx*0$ \\
                $xxx: (0*xx+x*0)*xxx+x*xx*1$
            }&
            \makecell[l]{
                $x: xx*xxx$ \\
                $xx: x*xxx$ \\
                $xxx: x*xx$
            }&
            \makecell[l]{
                $x: xx*xxx$ \\
                $xx: x*xxx$ \\
                $xxx: x*xx$
            }
            \\ \hline 

        \end{tabular}
        }
    \end{table}


    \item \textbf{Testcase 5: Constant}
    
    The input expression contains only constants, with no variables.
    \begin{table}[H]
        \centering
        \resizebox{1\columnwidth}{!}{
        \begin{tabular}{c|c|c|c} \hline 
            Input & \makecell[c]{Output\\(No simplification)} & \makecell[c]{Output\\(Simplifiled)}&  \makecell[c]{Reference\\Results}\\ \hline 

            $5$&
            \makecell[l]{
            }&
            \makecell[l]{
            }&
            \makecell[l]{
            }
            \\ \hline 

            $sin(1)*cos(2)*ln(3)$&
            \makecell[l]{
            }&
            \makecell[l]{
            }&
            \makecell[l]{
            }
            \\ \hline 

        \end{tabular}
        }
    \end{table}
    Program does not output anything for constant expressions.

    \subsection*{Analysis}   
    The program shows consistent results with the reference implementation, demonstrating correct symbolic differentiation and simplification. The output format is clear and concise, providing a structured representation of the derivative expression. The simplification process effectively reduces expression complexity, enhancing readability and interpretability. The program handles various mathematical functions and complex expressions, showcasing robustness and versatility in symbolic computation.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\chapter{Analysis and Comments}
\section*{Complexity Analysis\footnote{Some of the content is translated from Chinese.}}
\begin{itemize}
    \item \textbf{String to Expression Tree}
    \begin{itemize}
        \item \textbf{Time Complexity}: $O(n)$  

        The algorithm processes each token in the input expression exactly once, achieving linear time complexity $O(n)$. Operators and functions are managed through stack operations adhering to precedence rules, with each operator pushed and popped from the operator\_stack at most twice. Operand\_stack dynamically assembles subtrees in constant time per operation due to fixed node linkages for binary operators or unary functions.
        
        \item \textbf{Space Complexity}: $O(n)$  
        
        Space complexity is \(O(n)\) as both stacks grow proportionally to the input size. The operator\_stack holds pending operators and parentheses, while the operand\_stack stores partially constructed subtrees, never exceeding \(\lceil n/2 \rceil\) nodes. The final expression tree requires \(n\) nodes, with each token generating one node. Memory allocation scales linearly, ensuring efficient resource utilization while preserving the hierarchical structure of expressions.
    \end{itemize}
    
    \item \textbf{Expression Tree To String}
    \begin{itemize}
        \item \textbf{Time Complexity}: $O(n)$  

        The algorithm performs a single postorder traversal of the expression tree with \(n\) nodes. Each node is visited exactly once, and operations (priority checks, string formatting, parenthesis wrapping) execute in constant time per node. String concatenation using optimized buffers ensures linear time overall.
        \item \textbf{Space Complexity}: $O(n)$  

        Dominant factors include:
        \begin{itemize}
            \item Recursion stack depth (\(O(n)\) worst-case for skewed trees, \(O(\log n)\) for balanced trees)
            \item Output string storage (\(O(n)\) characters proportional to nodes)
            \item Temporary string fragments managed via in-place buffer reuse, avoiding redundant copies.  
        \end{itemize}
    \end{itemize}

    \item \textbf{Differentiation of Expression Tree}
    \begin{itemize}
        \item \textbf{Time Complexity}: \(O(n)\)
        
        The algorithm recursively traverses all \(n\) nodes of the expression tree exactly once. Each node applies differentiation rules (product rule, chain rule, etc.) in constant time, regardless of subtree generation complexity. While derivative expressions may theoretically grow exponentially (e.g., \(n\)-layer nested multiplications), practical implementations avoid redundant computations through shared subtree references, preserving linear scaling.

        \item \textbf{Space Complexity}: \(O(n^2\))
        
        Take multiplication as an example. The space complexity of the algorithm is \(O(n^2)\) because the derivative of a product of two functions is the sum of the product of the derivative of the first function and the second function and the product of the first function and the derivative of the second function. Assume that the function is a multiplication of \(n\) terms, $$ f(x) = u_1(x) \cdot u_2(x) \cdots u_n(x) = \prod_{i=1}^n u_i(x). $$
        then the derivative of the function is $$ f'(x) = \sum_{i=1}^n \left( u_i'(x) \cdot \prod_{\substack{j=1 \\ j \neq i}}^n u_j(x) \right). $$ It requires \(O(n^2)\) space to store the intermediate results.
    \end{itemize}

    \item \textbf{One-layer Simplification}
    \begin{itemize}
        \item \textit{Time Complexity}: $O(n)$ - Single pass through expression tree
        \item \textit{Space Complexity}: $O(1)$ - In-place simplification without additional memory
    \end{itemize}

    \item \textbf{Monomial Simplification}
    \begin{itemize}
        \item \textit{Time Complexity}: $O(n*m)$ - m is the number of variables in the monomial
        
        The algorithm processes each monomial component (coefficient, variable) exactly once, with linear time complexity \(O(n)\) for each monomial. Variable exponent management uses a linear search for matching variables, resulting in \(O(m)\) time complexity for each monomial. Coefficient normalization and monomial merging maintain linear scaling, ensuring efficient simplification across all monomial structures.
        \item \textit{Space Complexity}: $O(m)$ - Monomial structure with variable and exponent arrays
    \end{itemize}

\end{itemize}

\section*{Improvements}
\begin{itemize}
    \item \textbf{Simplification}:
    \begin{itemize}
        \item Using polynomial simplification algorithms to handle complex expressions, which is similar to the monomial simplification but extends to polynomial structures.
        \item Using hash table in monomial simplification to improve node matching efficiency.
        \item Remove parentheses with distributive law.
    \end{itemize}
    \item \textbf{Differentiation}:
    
    Cache results of identical expressions to avoid redundant calculations.
    \item \textbf{Input}:
    
    Add error handling for invalid expressions or unsupported functions/operators.
\end{itemize}


\chapter*{Appendix: Source Code\footnote{Source files with sufficient inline comments are provided in the "code" folder.}}
\addcontentsline{toc}{chapter}{Appendix: Source Code}

\begin{itemize}
    \item \textbf{Folder: ast}
    
    This folder includes three modules: stack, ast, and astmath.
    \begin{itemize}
        \item \textbf{stack.c/stack.h}
        
        This module provides the implementation and interface for a stack data structure that stores pointers to `Node` elements. The stack is implemented using a dynamic array and supports basic stack operations such as push, pop, peek, and checking if the stack is empty.
        \begin{itemize}
            \item stack.h
            \inputminted{c}{../code/ast/stack.h}
            \item stack.c
            \inputminted{c}{../code/ast/stack.c}
        \end{itemize}

        \item \textbf{ast.c/ast.h}
        
        This module provides the implementation and interface for an Abstract Syntax Tree (AST) used to represent mathematical expressions. It includes definitions for node types, node structures, and functions to create, manipulate, and convert ASTs.
        \begin{itemize}
            \item ast.h
            \inputminted{c}{../code/ast/ast.h}
            \item ast.c
            \inputminted{c}{../code/ast/ast.c}
        \end{itemize}

        \item \textbf{astmath.c/astmath.h}
        
        This module provides mathematical operations that can be performed on the AST, such as differentiation, finding variables, and checking structural equality of nodes.
        \begin{itemize}
            \item astmath.h
            \inputminted{c}{../code/ast/astmath.h}
            \item astmath.c
            \inputminted{c}{../code/ast/astmath.c}
        \end{itemize}
    \end{itemize}

    \item \textbf{Folder: simplificator}
    
    This folder includes two modules: one\_layer and monomial.
    \begin{itemize}
        \item \textbf{one\_layer.c/one\_layer.h}
        
        This module provides the implementation and interface for one-layer simplification of an AST. It simplifies mathematical expressions by applying basic algebraic rules.
        \begin{itemize}
            \item one\_layer.h
            \inputminted{c}{../code/simplificator/one_layer.h}
            \item one\_layer.c
            \inputminted{c}{../code/simplificator/one_layer.c}
        \end{itemize}

        \item \textbf{monomial.c/monomial.h}
        
        This module provides the implementation and interface for handling monomials in the simplification process of mathematical expressions. It includes functions to create, manipulate, and convert monomials to and from AST nodes.
        \begin{itemize}
            \item monomial.h
            \inputminted{c}{../code/simplificator/monomial.h}
            \item monomial.c
            \inputminted{c}{../code/simplificator/monomial.c}
        \end{itemize}
    \end{itemize}

    \item \textbf{Misc and executables}
    \begin{itemize}
        \item \textbf{CMakeLists.txt}

        CMakeLists.txt is the core configuration file for the CMake build system, defining project structure, compilation options, dependencies, and cross-platform build rules to generate native build environments (e.g., Makefiles or Visual Studio projects).
        \inputminted{cmake}{../code/CMakeLists.txt}

        \item \textbf{utils.c/utils.h}
        
        This module provides utility functions that are used across various parts of the project. These functions include string manipulation, mathematical computations, and expression modifications.
        \begin{itemize}
            \item utils.h
            \inputminted{c}{../code/utils.h}
            \item utils.c
            \inputminted{c}{../code/utils.c}
        \end{itemize}

        \item \textbf{simplificator.c}
        
        This module provides the main entry point for the simplification program. It reads a mathematical expression from the command line, processes it through various simplification steps, and outputs the simplified expression.
        \inputminted{c}{../code/simplificator.c}

        \item \textbf{differentiate.c}
        
        This module provides the main entry point for the differentiation program. It reads a mathematical expression and a variable from the command line, processes the expression to compute its derivative with respect to the given variable, and outputs the result.
        \inputminted{c}{../code/differentiate.c}

        \item \textbf{differentiate\_simplified.c}
        
        This module provides a simplified entry point for the differentiation program. It reads a mathematical expression and optionally a variable from the command line, processes the expression to compute its derivative with respect to the given variable, simplifies the derivative, and outputs the result.
        \inputminted{c}{../code/differentiate_simplified.c}
    \end{itemize}
\end{itemize}


\chapter*{Declaration}
I hereby declare that all the work done in this project titled "Hard Autograd for Algebraic Expressions" is of my independent effort.

\end{document}
```
